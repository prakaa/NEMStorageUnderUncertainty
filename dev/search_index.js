var documenterSearchIndex = {"docs":
[{"location":"formulations/#Model-Formulations","page":"Model Formulations","title":"Model Formulations","text":"","category":"section"},{"location":"formulations/","page":"Model Formulations","title":"Model Formulations","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/formulations.jl\"]","category":"page"},{"location":"formulations/#NEMStorageUnderUncertainty.StandardFormulation","page":"Model Formulations","title":"NEMStorageUnderUncertainty.StandardFormulation","text":"struct StandardFormulation <: NEMStorageUnderUncertainty.StorageModelFormulation\n\nSummary\n\nMaximises storage revenue:\n\nAll periods are treated (weighted) equally\nNo cycling/throughput limits are modelled\nRevenue is purely defined by the spot price for energy\nIntertemporal SoC constraints are applied\n\nbeginaligned\n  max_t quad  sum_t=1^Ttaulambda_t(p_t-q_t)\n  textrmst quad  u_t in 01    \n   p_t geq 0 \n   q_t geq 0 \n   p_t - barpleft(1-u_tright) leq 0\n   q_t - barpu_t leq 0\n   underlinee leq e_t leq bare    \n   e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n   e_1 = e_0 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty._initialise_model-Tuple{}","page":"Model Formulations","title":"NEMStorageUnderUncertainty._initialise_model","text":"_initialise_model(\n;\n    silent,\n    time_limit_sec,\n    string_names\n) -> JuMP.Model\n\n\nSummary\n\nArguments\n\nsilent: Default false. If true, turn off JuMP/solver output\ntime_limit_sec: Default nothing. Number of seconds before solver times out.\nstring_names: Default true. If false, disables JuMP string names, which can improve speed/performance.\n\nReturns\n\nA JuMP model\n\nMethods\n\n_initialise_model(; silent, time_limit_sec, string_names)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/formulations.jl:40.\n\n\n\n\n\n","category":"method"},{"location":"formulations/#Model-Components","page":"Model Formulations","title":"Model Components","text":"","category":"section"},{"location":"formulations/","page":"Model Formulations","title":"Model Formulations","text":"Variables\nConstraints\nObjectives","category":"page"},{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/variables.jl\"]","category":"page"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_charge_state!-Tuple{JuMP.Model, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_charge_state!","text":"_add_variable_charge_state!(\n    model::JuMP.Model,\n    times::Vector{Dates.DateTime}\n) -> JuMP.Containers.DenseAxisArray{JuMP.VariableRef, 1, Tuple{Vector{Dates.DateTime}}, Tuple{JuMP.Containers._AxisLookup{Dict{Dates.DateTime, Int64}}}}\n\n\nSummary\n\nAdds binary variable that indicates charging (i.e. u_t=1) when charging.\n\nArguments\n\nmodel: JuMP model\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variable_charge_state!(model, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_soc!","text":"_add_variable_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> JuMP.Containers.DenseAxisArray\n\n\nSummary\n\nAdds variable that tracks state-of-charge (SoC, e_t).\n\nThe following variable bound is applied: underlinee leq e_t leq bare, where the limits represent the lower and upper SoC limits obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variable_soc!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:39.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variables_power!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variables_power!","text":"_add_variables_power!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> Tuple{JuMP.Containers.DenseAxisArray, JuMP.Containers.DenseAxisArray}\n\n\nSummary\n\nAdds variables for charging in MW (q_t) and discharging in MW (p_t).\n\nThe following variable bounds are applied:\n\n0 leq p_t leq barp\n0 leq q_t leq barp\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variables_power!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/constraints.jl\"]","category":"page"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_initial_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_initial_soc!","text":"_add_constraint_initial_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> JuMP.ConstraintRef{JuMP.Model}\n\n\nSummary\n\nAdds the following constraint to model: e_1 = e_0, where e_0 is obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_constraint_initial_soc!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:39.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!","text":"_add_constraint_intertemporal_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> Union{Nothing, JuMP.Containers.DenseAxisArray}\n\n\nSummary\n\nAdds the following constraint to model if times has length ≥ 2: e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n\neta are obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_constraint_intertemporal_soc!(model, storage, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:60.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraints_charge_state!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraints_charge_state!","text":"_add_constraints_charge_state!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> Tuple{JuMP.Containers.DenseAxisArray, JuMP.Containers.DenseAxisArray}\n\n\nSummary\n\nAdds two constraints to model:\n\np_t - barpleft(1-u_tright) leq 0\nq_t - barpu_t leq 0\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_constraints_charge_state!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:12.\n\n\n\n\n\n","category":"method"},{"location":"devices/#Storage-Devices","page":"Storage Devices","title":"Storage Devices","text":"","category":"section"},{"location":"devices/","page":"Storage Devices","title":"Storage Devices","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"devices.jl\"]","category":"page"},{"location":"devices/#NEMStorageUnderUncertainty.BESS","page":"Storage Devices","title":"NEMStorageUnderUncertainty.BESS","text":"BESS(\n    power_capacity::Float64,\n    energy_capacity::Float64,\n    soc_min::Float64,\n    soc_max::Float64,\n    η_charge::Float64,\n    η_discharge::Float64,\n    soc₀::Float64\n)\nBESS(\n    power_capacity::Float64,\n    energy_capacity::Float64,\n    soc_min::Float64,\n    soc_max::Float64,\n    η_charge::Float64,\n    η_discharge::Float64,\n    soc₀::Float64,\n    throughput::Float64\n) -> BESS\n\n\nSummary\n\nInitialises a battery energy storage system (BESS).\n\nthroughput (in MWh) can be supplied in cases where the BESS has already undertaken energy storage and discharge. This is akin to cycling but is independent of storage capacity (significant where calendar and/or cycling degradation is accounted for). If not supplied, default value is 0.0.\n\nReturns\n\nA BESS\n\nMethods\n\nBESS(\n    power_capacity,\n    energy_capacity,\n    soc_min,\n    soc_max,\n    η_charge,\n    η_discharge,\n    soc₀\n)\nBESS(\n    power_capacity,\n    energy_capacity,\n    soc_min,\n    soc_max,\n    η_charge,\n    η_discharge,\n    soc₀,\n    throughput\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/devices.jl:34.\n\n\n\n\n\n","category":"type"},{"location":"devices/#NEMStorageUnderUncertainty.StorageDevice","page":"Storage Devices","title":"NEMStorageUnderUncertainty.StorageDevice","text":"abstract type StorageDevice\n\n\n\n\n\n","category":"type"},{"location":"data/#Price-Data-Compilers","page":"Price Data Compilers","title":"Price Data Compilers","text":"","category":"section"},{"location":"data/","page":"Price Data Compilers","title":"Price Data Compilers","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"data.jl\"]","category":"page"},{"location":"data/#NEMStorageUnderUncertainty.ActualPrice","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ActualPrice","text":"struct ActualPrice <: NEMStorageUnderUncertainty.PriceData\n\nstart_time::Dates.DateTime\nend_time::Dates.DateTime\ndata::DataFrames.DataFrame\n\n\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.ForecastPrice","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ForecastPrice","text":"struct ForecastPrice <: NEMStorageUnderUncertainty.PriceData\n\nrun_start::Dates.DateTime\nrun_end::Dates.DateTime\nforecasted_start::Dates.DateTime\nforecasted_end::Dates.DateTime\ndata::DataFrames.DataFrame\n\n\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.get_all_actual_prices-Tuple{String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_actual_prices","text":"get_all_actual_prices(\n    path::String\n) -> NEMStorageUnderUncertainty.ActualPrice\n\n\nSummary\n\nObtains actual price data from parquet files located at path\n\nArguments\n\npath: Path to parquet partitions\n\nReturns\n\nDataFrame with settlement date, region and corresponding energy prices\n\nMethods\n\nget_all_actual_prices(path)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:32.\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_all_forecast_prices-Tuple{String, String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_forecast_prices","text":"get_all_forecast_prices(\n    pd_path::String,\n    p5_path::String\n) -> NEMStorageUnderUncertainty.ForecastPrice\n\n\nSummary\n\nObtains and compiles all forecasted price data from parquet files located at the P5MIN path (p5_path) and the PREDISPATCH path (pd_path)\n\nNote that Parquet.jl cannot parse Timestamps from .parquet, so we use unix2datetime.\n\nArguments\n\npd_path: Path to PREDISPATCH parquet partitions\np5_path: Path to P5MIN parquet partitions\n\nReturns\n\nCompiled forecast data, with PREDISPATCH forecasts that overlap with P5MIN removed. Compiled forecast data has actual run times, forecasted times, regions and their corresponding energy prices.\n\nMethods\n\nget_all_forecast_prices(pd_path, p5_path)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:64.\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_prices_by_times-Tuple{NEMStorageUnderUncertainty.ActualPrice, Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_prices_by_times","text":"get_prices_by_times(\n    prices::NEMStorageUnderUncertainty.ActualPrice,\n    times::Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}\n) -> NEMStorageUnderUncertainty.ActualPrice\n\n\nSummary\n\nFilters actual prices based on supplied times (start, end)\n\nArguments\n\nprices: ActualPrice produced by get_all_actual_prices\ntimes: (start_time, end_time), inclusive\n\nReturns\n\nFiltered ActualPrice\n\nMethods\n\nget_prices_by_times(prices, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:175.\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_prices_by_times-Tuple{NEMStorageUnderUncertainty.ForecastPrice}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_prices_by_times","text":"get_prices_by_times(\n    prices::NEMStorageUnderUncertainty.ForecastPrice;\n    forecasted_times,\n    run_times\n) -> NEMStorageUnderUncertainty.ForecastPrice\n\n\nSummary\n\nFilters forecast prices based on supplied run_times (start, end) and forecasted_times (start, end)\n\nArguments\n\nprices: ForecastPrice produced by get_all_forecast_prices\nforecasted_times: (start_time, end_time), inclusive\nrun_times: (start_time, end_time), inclusive\n\nReturns\n\nFiltered ForecastPrice\n\nMethods\n\nget_prices_by_times(prices; forecasted_times, run_times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:126.\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/objectives.jl\"]","category":"page"},{"location":"objectives/#NEMStorageUnderUncertainty._add_objective_standard!-Tuple{JuMP.Model, Vector{<:Union{Missing, Float64}}, Vector{Dates.DateTime}, Float64}","page":"Objectives","title":"NEMStorageUnderUncertainty._add_objective_standard!","text":"_add_objective_standard!(\n    model::JuMP.Model,\n    prices::Vector{<:Union{Missing, Float64}},\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> Any\n\n\nSummary\n\nAdds a standard revenue-maximising objective function:\n\nbeginaligned\nmax_t quad  sum_ttaulambda_t(p_t - q_t)\nendaligned\n\nArguments\n\nmodel: JuMP model\nprices: A Vector of prices in /MWh\ntimes: A Vector of DateTimes\nτ: Frequency of prices in hours\n\nMethods\n\n_add_objective_standard!(model, prices, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/objectives.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"#NEMStorageUnderUncertainty-Documentation","page":"Home","title":"NEMStorageUnderUncertainty Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modelling framework built to explore the impact of future market information (forecasts) on the operation of energy storage in the National Electricity Market (NEM).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"devices.md\", \"data.md\", \"formulations.md\"]\nDepth = 1","category":"page"}]
}
