var documenterSearchIndex = {"docs":
[{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/variables.jl\"]","category":"page"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_charge_state!-Tuple{JuMP.Model, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_charge_state!","text":"_add_variable_charge_state!(\nmodel::JuMP.Model, times::Vector{DateTime}\n)\n\nAdds binary variable that indicates charging (i.e. u_t=1) when charging.\n\nArguments\n\nmodel: JuMP model\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_soc!","text":"_add_variable_soc!(\nmodel::JuMP.Model, storage::StorageDevice, times::Vector{DateTime}\n)\n\nAdds variable that tracks state-of-charge (SoC, e_t).\n\nThe following variable bound is applied: underlinee leq e_t leq bare, where the limits represent the lower and upper SoC limits obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variables_power!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variables_power!","text":"_add_variables_power!(\nmodel::JuMP.Model, storage::StorageDevice, times::Vector{DateTime}\n)\n\nAdds variables for charging in MW (q_t) and discharging in MW (p_t).\n\nThe following variable bounds are applied:\n\n0 leq p_t leq barp\n0 leq q_t leq barp\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/constraints.jl\"]","category":"page"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_initial_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_initial_soc!","text":"_add_constraint_initial_soc!(\n    model::JuMP.Model, storage::StorageDevice, times::Vector{DateTime}\n)\n\nAdds the following constraint to model: e_1 = e_0, where e_0 is obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!","text":"addconstraintintertemporalsoc!(     model::JuMP.Model, storage::StorageDevice, times::Vector{DateTime}     )\n\nAdds the following constraint to model: e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n\neta are obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraints_charge_state!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraints_charge_state!","text":"_add_constraints_charge_state!(\n    model::JuMP.Model, storage::StorageDevice, times::Vector{DateTime}\n)\n\nAdds two constraints to model:\n\np_t - barpleft(1-u_tright) leq 0\nq_t - barpu_t leq 0\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\n\n\n\n\n","category":"method"},{"location":"devices/#Storage-Devices","page":"Storage Devices","title":"Storage Devices","text":"","category":"section"},{"location":"devices/","page":"Storage Devices","title":"Storage Devices","text":"BESS","category":"page"},{"location":"devices/#NEMStorageUnderUncertainty.BESS","page":"Storage Devices","title":"NEMStorageUnderUncertainty.BESS","text":"BESS(\n    power_capacity::Float64,\n    nominal_energy_capacity::Float64,\n    soc_min::Float64,\n    soc_max::Float64,\n    η_charge::Float64,\n    η_discharge::Float64,\n    soc₀::Float64\n)\n\nInitialises a battery energy storage system (BESS)\n\nArguments\n\npower_capacity: Maximum charge/discharge power capacity (MW)\nenergy_capacity: Maximum energy capacity (MWh)\nsoc_min: Minimum allowable operational state of charge (MWh)\nsoc_max: Maximum allowable operational state of charge (MWh)\nη_charge: Charging efficiency (0-1)\nη_discharge: Discharge efficiency (0-1)\nsoc₀: Initial state of charge (MWh)\nthroughput: Energy throughput (MWh)\n\nReturns\n\nA BESS. The following properties are immutable:\n\npower_capacity\nη_charge\nη_discharge\n\n\n\n\n\n","category":"type"},{"location":"model_formulations/#Model-Formulations","page":"Formulations","title":"Model Formulations","text":"","category":"section"},{"location":"model_formulations/","page":"Formulations","title":"Formulations","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/model_formulations.jl\"]","category":"page"},{"location":"model_formulations/#NEMStorageUnderUncertainty.build_storage_model","page":"Formulations","title":"NEMStorageUnderUncertainty.build_storage_model","text":"beginaligned\n  max_t quad  sum_t=1^Ttaulambda_t(p_t-q_t)\n  textrmst quad  u_t in 01    \n   p_t geq 0 \n   q_t geq 0 \n   p_t - barpleft(1-u_tright) leq 0\n   q_t - barpu_t leq 0\n   underlinee leq e_t leq bare    \n   e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n   e_1 = e_0 \nendaligned\n\nmath\n\n\n\n\n\n","category":"function"},{"location":"model_formulations/#Model-Components","page":"Formulations","title":"Model Components","text":"","category":"section"},{"location":"model_formulations/","page":"Formulations","title":"Formulations","text":"Variables\nConstraints\nObjectives","category":"page"},{"location":"data/#Price-Data-Compilers","page":"Price Data Compilers","title":"Price Data Compilers","text":"","category":"section"},{"location":"data/","page":"Price Data Compilers","title":"Price Data Compilers","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"data.jl\"]","category":"page"},{"location":"data/#NEMStorageUnderUncertainty.ActualPrice","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ActualPrice","text":"\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.ForecastPrice","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ForecastPrice","text":"\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.get_all_actual_prices-Tuple{String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_actual_prices","text":"get_all_actual_prices(path::String)\n\nObtains actual price data from parquet files located at path\n\nArguments\n\npath: Path to parquet partitions\n\nReturns\n\nDataFrame with settlement date, region and corresponding energy prices\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_all_forecast_prices-Tuple{String, String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_forecast_prices","text":"get_all_forecast_prices(pd_path::String, p5_path::String)\n\nObtains and compiles all forecasted price data from parquet files located at the P5MIN path (p5_path) and the PREDISPATCH path (pd_path)\n\nNote that Parquet.jl cannot parse Timestamps from .parquet, so we use unix2datetime.\n\nArguments\n\npd_path: Path to PREDISPATCH parquet partitions\np5_path: Path to P5MIN parquet partitions\n\nReturns\n\nCompiled forecast data, with PREDISPATCH forecasts that overlap with P5MIN removed. Compiled forecast data has actual run times, forecasted times, regions and their corresponding energy prices.\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_prices_by_times-Tuple{NEMStorageUnderUncertainty.ActualPrice, Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_prices_by_times","text":"get_prices_by_times(\n    prices::ActualPrice, times::Union{Tuple{DateTime,DateTime},Nothing}\n)\n\nFilters actual prices based on supplied times (start, end)\n\nArguments\n\nprices: ActualPrice produced by get_all_actual_prices\ntimes: (starttime, endtime), inclusive\n\nReturns\n\nFiltered ActualPrice\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_prices_by_times-Tuple{NEMStorageUnderUncertainty.ForecastPrice}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_prices_by_times","text":"get_prices_by_times(\nprices::ForecastPrice;\nforecasted_times::Union{Tuple{DateTime,DateTime},Nothing}=nothing,\nrun_times::Union{Tuple{DateTime,DateTime},Nothing}=nothing,\n)\n\nFilters forecast prices based on supplied run_times (start, end) and forecasted_times (start, end)\n\nArguments\n\nprices: ForecastPrice produced by get_all_forecast_prices\nforecasted_times: (starttime, endtime), inclusive\nrun_times: (starttime, endtime), inclusive\n\nReturns\n\nFiltered ForecastPrice\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/objectives.jl\"]","category":"page"},{"location":"objectives/#NEMStorageUnderUncertainty._add_objective_standard!-Tuple{JuMP.Model, Vector{<:Union{Missing, Float64}}, Vector{Dates.DateTime}, Float64}","page":"Objectives","title":"NEMStorageUnderUncertainty._add_objective_standard!","text":"_add_objective_standard!(\nmodel::JuMP.Model, prices::Vector{AbstractFloat}, times::Vector{DateTime}, τ::Float64\n)\n\nAdds a standard revenue-maximising objective function:\n\nbeginaligned\nmax_t quad  sum_ttaulambda_t(p_t - q_t)\nendaligned\n\nArguments\n\nmodel: JuMP model\nprices: A Vector of prices in /MWh\ntimes: A Vector of DateTimes\nτ: Frequency of prices in hours\n\n\n\n\n\n","category":"method"},{"location":"#Model-Documentation","page":"Home","title":"Model Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is documentation for a modelling framework built to explore the impact of future market information (forecasts) on the operation of energy storage in the National Electricity Market (NEM).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"devices.md\", \"data.md\", \"model_formulations.md\"]\nDepth = 1","category":"page"}]
}
