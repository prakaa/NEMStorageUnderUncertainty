var documenterSearchIndex = {"docs":
[{"location":"results/#Simulation-Results-Processing-and-Calculations","page":"Results Processing","title":"Simulation Results Processing and Calculations","text":"","category":"section"},{"location":"results/","page":"Results Processing","title":"Results Processing","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"results.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"results/#NEMStorageUnderUncertainty.calculate_summaries_and_vpi_vpf_across_scenarios-Tuple{String}","page":"Results Processing","title":"NEMStorageUnderUncertainty.calculate_summaries_and_vpi_vpf_across_scenarios","text":"calculate_summaries_and_vpi_vpf_across_scenarios(\n    sim_folder::String\n) -> Dict{String, DataFrames.DataFrame}\n\n\nSummary\n\nSummarises results for each simulated formulation and then calculates values of perfect information and foresight.\n\nFor each state, this function cycles through each simulated formulation and:\n\nCalculates summary results (i.e. annual revenue and mean relative gap)\nCalculates the value of perfect information and value of perfect foresight\n\nFor a single state, the VPIs and VPFs across simulated formulations are then released information a JLD2 file in the results folder, along with summary results for each simulated formulation.\n\nArguments\n\nsim_folder: Path containing simulations of different formulations and their results.\n\nReturns\n\nDict mapping each state to DataFrame with VPI and VPF for each formulation and lookahead.\n\nMethods\n\ncalculate_summaries_and_vpi_vpf_across_scenarios(sim_folder)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/results.jl:191.\n\n\n\n\n\n","category":"method"},{"location":"results/#NEMStorageUnderUncertainty.calculate_vpi_vpf-Tuple{DataFrames.DataFrame}","page":"Results Processing","title":"NEMStorageUnderUncertainty.calculate_vpi_vpf","text":"calculate_vpi_vpf(\n    df::DataFrames.DataFrame\n) -> DataFrames.DataFrame\n\n\nSummary\n\nCalculates values of perfect information and foresight as absolute values (in AUD) and as a percentage of perfect foresight revenue.\n\nValue of perfect information: What is the additional benefit (revenue) that a participant could gain if they were to know exactly what the market prices will be in the lookahead horizon.\n\nVPI = textrmRevenue_textrmActual Data Simulation -  textrmRevenue_textrmForecast Data Simulation\n\nValue of perfect foresight: What is the additional benefit (revenue) that a participant could gain if they were to know exactly what the market prices will be over the entire year\n\nVPF = textrmRevenue_textrmPerfect Foresight -  textrmRevenue_textrmForecast Data Simulation\n\nN.B. This function assumes that the input df only has data that corresponds to a device of a particular energy_capacity.\n\nArguments\n\ndf: DataFrame produced by _summarise_simulations\n\nReturns\n\nDataFrame with absolute values of perfect information and foresight, and the same values as a percentage of perfect foresight revenue.\n\nMethods\n\ncalculate_vpi_vpf(df)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/results.jl:127.\n\n\n\n\n\n","category":"method"},{"location":"devices/#Storage-Devices","page":"Storage Devices","title":"Storage Devices","text":"","category":"section"},{"location":"devices/","page":"Storage Devices","title":"Storage Devices","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"devices.jl\"]","category":"page"},{"location":"devices/#NEMStorageUnderUncertainty.BESS","page":"Storage Devices","title":"NEMStorageUnderUncertainty.BESS","text":"BESS(\n    power_capacity::Float64,\n    energy_capacity::Float64,\n    soc_min::Float64,\n    soc_max::Float64,\n    η_charge::Float64,\n    η_discharge::Float64,\n    soc₀::Float64\n) -> BESS\nBESS(\n    power_capacity::Float64,\n    energy_capacity::Float64,\n    soc_min::Float64,\n    soc_max::Float64,\n    η_charge::Float64,\n    η_discharge::Float64,\n    soc₀::Float64,\n    throughput::Float64\n) -> BESS\n\n\nSummary\n\nInitialises a battery energy storage system (BESS).\n\nthroughput (in MWh) can be supplied in cases where the BESS has already undertaken energy storage and discharge. This is akin to cycling but is independent of storage capacity (significant where calendar and/or cycling degradation is accounted for). If not supplied, default value is 0.0.\n\nReturns\n\nA BESS\n\nMethods\n\nBESS(\n    power_capacity,\n    energy_capacity,\n    soc_min,\n    soc_max,\n    η_charge,\n    η_discharge,\n    soc₀\n)\nBESS(\n    power_capacity,\n    energy_capacity,\n    soc_min,\n    soc_max,\n    η_charge,\n    η_discharge,\n    soc₀,\n    throughput\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/devices.jl:43.\n\n\n\n\n\n","category":"type"},{"location":"devices/#NEMStorageUnderUncertainty.StorageDevice","page":"Storage Devices","title":"NEMStorageUnderUncertainty.StorageDevice","text":"abstract type StorageDevice\n\n\n\n\n\n","category":"type"},{"location":"data/#Price-Data-Compilers","page":"Price Data Compilers","title":"Price Data Compilers","text":"","category":"section"},{"location":"data/","page":"Price Data Compilers","title":"Price Data Compilers","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"data.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"data/#NEMStorageUnderUncertainty.ActualData","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ActualData","text":"struct ActualData{T<:AbstractFloat} <: NEMStorageUnderUncertainty.NEMData\n\nregion::String\ntimes::Vector{Dates.DateTime}\nprices::Vector{T} where T<:AbstractFloat\nτ::AbstractFloat\n\nA data structure used to store actual price data and metadata\n\n\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.ForecastData","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.ForecastData","text":"struct ForecastData{T<:AbstractFloat} <: NEMStorageUnderUncertainty.NEMData\n\nregion::String\nrun_times::Vector{Dates.DateTime}\nforecasted_times::Vector{Dates.DateTime}\nprices::Vector{T} where T<:AbstractFloat\nτ::AbstractFloat\nrun_time_aligned::Bool\n\nA data structure used to store forecast price data and metadata\n\nrun_time_aligned indicates whether PD and P5MIN raw data used to construct a ForecastData instance were aligned along actual_run_time, i.e. same start and end actual_run_time.\n\n\n\n\n\n","category":"type"},{"location":"data/#NEMStorageUnderUncertainty.get_ActualData","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_ActualData","text":"get_ActualData(\n    actual_data::DataFrames.DataFrame,\n    region::String\n) -> NEMStorageUnderUncertainty.ActualData\nget_ActualData(\n    actual_data::DataFrames.DataFrame,\n    region::String,\n    actual_time_window::Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}\n) -> NEMStorageUnderUncertainty.ActualData\n\n\nSummary\n\nGet an ActualData instance.\n\nArguments:\n\nactual_data: DataFrame generated by get_all_actual_data\nregion: Market region in the NEM\nactual_time_window: Tuple used to filter DataFrame\n\nReturns:\n\nAn ActualData instance.\n\nMethods\n\nget_ActualData(actual_data, region)\nget_ActualData(actual_data, region, actual_time_window)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:83.\n\n\n\n\n\n","category":"function"},{"location":"data/#NEMStorageUnderUncertainty.get_ForecastData","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_ForecastData","text":"get_ForecastData(\n    pd_data::DataFrames.DataFrame,\n    p5_data::DataFrames.DataFrame,\n    region::String\n) -> NEMStorageUnderUncertainty.ForecastData\nget_ForecastData(\n    pd_data::DataFrames.DataFrame,\n    p5_data::DataFrames.DataFrame,\n    region::String,\n    run_time_window::Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}\n) -> NEMStorageUnderUncertainty.ForecastData\nget_ForecastData(\n    pd_data::DataFrames.DataFrame,\n    p5_data::DataFrames.DataFrame,\n    region::String,\n    run_time_window::Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}},\n    forecasted_time_window::Union{Nothing, Tuple{Dates.DateTime, Dates.DateTime}}\n) -> NEMStorageUnderUncertainty.ForecastData\n\n\nSummary\n\nGet a ForecastData instance.\n\nImputes PREDISPATCH data. Specifically, this involves:\n\nBackwards filling forecasted_time\nA forecast at the end of a settlement period should reflect previous 5 intervals\ne.g. price at 13:30 is back filled for 13:25, 13:20 ... 13:05\nForward filling run_time\nLatest forecast should be used until a new forecast is run\ne.g. prices from run at 13:30 are used for 13:35, 13:40 ... 13:55\nWe then need to remove periods when run_time < forecasted_time\n\nImputation is carried out using Impute.jl.\n\nArguments:\n\npd_data, p5_data: DataFrames generated by get_all_pd_and_p5_data\nregion: Market region in the NEM\nrun_time_window: Tuple used to filter DataFrame based on run times\nforecasted_time_window: Tuple used to filter DataFrame based for forecasted time\n\nReturns:\n\nAn ForecastData instance.\n\nMethods\n\nget_ForecastData(pd_data, p5_data, region)\nget_ForecastData(pd_data, p5_data, region, run_time_window)\nget_ForecastData(\n    pd_data,\n    p5_data,\n    region,\n    run_time_window,\n    forecasted_time_window\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:317.\n\n\n\n\n\n","category":"function"},{"location":"data/#NEMStorageUnderUncertainty.get_all_actual_data-Tuple{String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_actual_data","text":"get_all_actual_data(path::String) -> DataFrames.DataFrame\n\n\nSummary\n\nObtains actual data from parquet files located at path\n\nArguments\n\npath: Path to parquet partitions\n\nReturns\n\nDataFrame with settlement date, region and corresponding energy prices\n\nMethods\n\nget_all_actual_data(path)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"data/#NEMStorageUnderUncertainty.get_all_pd_and_p5_data-Tuple{String, String}","page":"Price Data Compilers","title":"NEMStorageUnderUncertainty.get_all_pd_and_p5_data","text":"get_all_pd_and_p5_data(\n    pd_path::String,\n    p5_path::String\n) -> Tuple{DataFrames.DataFrame, DataFrames.DataFrame}\n\n\nSummary\n\nObtains and compiles all forecasted price data from parquet files located at the P5MIN path (p5_path) and the PREDISPATCH path (pd_path)\n\nNote that Parquet.jl cannot parse Timestamps from .parquet, so we use unix2datetime.\n\nArguments\n\npd_path: Path to PREDISPATCH parquet partitions\np5_path: Path to P5MIN parquet partitions\n\nReturns\n\nCompiled forecast data with nominal run times, forecasted times, regions and their corresponding energy prices.\n\nMethods\n\nget_all_pd_and_p5_data(pd_path, p5_path)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/data.jl:130.\n\n\n\n\n\n","category":"method"},{"location":"terminology/#Terminology","page":"Terminology","title":"Terminology","text":"","category":"section"},{"location":"terminology/#Price-Data","page":"Terminology","title":"Price Data","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"All price data is in AUD/MW/hr.","category":"page"},{"location":"terminology/#Forecast","page":"Terminology","title":"Forecast","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Forecast data refers to price data compiled from 30-minute pre-dispatch (PD, or PREDISPATCH) and 5-minute pre-dispatch (P5MIN or 5MPD) forecasts.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"30-minute pre-dispatch forecasts run half an hour and one hour prior to real-time (actual run time) are removed as they overlap with the P5MIN horizon.","category":"page"},{"location":"terminology/#Actual","page":"Terminology","title":"Actual","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Actual price data refers to cleared prices for a region as published by AEMO.","category":"page"},{"location":"terminology/#Simulation-Components-and-Periods","page":"Terminology","title":"Simulation Components and Periods","text":"","category":"section"},{"location":"terminology/#Model","page":"Terminology","title":"Model","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"The storage device operator has information available at decision time t_0 (i.e. end of an interval), and, based on an optimisation problem from end of the next interval (t_1) to t_1 + t_h where t_h is the lookahead horizon, makes decisions for future intervals.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"One (i.e. t_1) or more of the decisions at the start of the model period can be binding. These decisions are fixed and cannot be updated by the next model period (i.e. the next model period is run with the last binding decision interval of the previous model period as the decision time)\nRemaining decisions in the lookahead horizon are non binding. Decisions for these intervals can be updated by successive model periods in the simulation","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Models are characterised by:","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"StorageModelFormulation, which describe which variables, constraints and/or objective function is incorporated into the optimisation model\nDegradationModel, which describes how degradation is modelled and simulated","category":"page"},{"location":"terminology/#Simulation","page":"Terminology","title":"Simulation","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"A simulation is a rolling horizon optimal control problem in which:","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"At the decision time, initial storage state and price data are inputs into a model of the first lookahead horizon\nThe model is solved, and certain decisions are considered binding\nThe next decision time is the last binding interval. The storage state is updated, the lookahead horizon is rolled along, and another model is constructed and solved\nThis is repeated until the entire simulation period has been simulated","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Simulations can be run with actual price data, or with forecast price data.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Results from simulations can be compared to a perfect foresight model, in which all intervals are optimised simultaneously using actual price data.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"In the example below, simulations and a perfect foresight model are run from t to t+10. Each simulation consists of models with a lookahead horizon of 3 and a binding horizon of 1. The perfect foresight model optimises storage device operation over the entire data period.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"(Image: Example of simulation with a lookahead horizon of 3 and a binding horizon of 1)","category":"page"},{"location":"simulation_utils/#Simulation-Utilities","page":"Simulation Utilities","title":"Simulation Utilities","text":"","category":"section"},{"location":"simulation_utils/","page":"Simulation Utilities","title":"Simulation Utilities","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"simulation_utils.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"simulation_utils/#NEMStorageUnderUncertainty.calculate_actual_revenue-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Float64}","page":"Simulation Utilities","title":"NEMStorageUnderUncertainty.calculate_actual_revenue","text":"calculate_actual_revenue(\n    sim_results::DataFrames.DataFrame,\n    actual_price_data::DataFrames.DataFrame,\n    τ::Float64\n) -> Any\n\n\nSummary\n\nCalculates actual revenue and adds it as a column to sim_results.\n\nRevenue is calculated for binding decisions\nnon binding decisions have missing revenue\n\nArguments:\n\nsim_results: DataFrame of simulation results\nactual_price_data: DataFrame with actual price data\n\n(with SETTLEMENTDATE column and prices covering simulation period)\n\ntau: Interval length in hours\n\nReturns\n\nsim_results with revenue column.\n\nMethods\n\ncalculate_actual_revenue(sim_results, actual_price_data, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/simulation_utils.jl:18.\n\n\n\n\n\n","category":"method"},{"location":"simulation_utils/#NEMStorageUnderUncertainty.results_to_jld2-Tuple{String, String, String, DataFrames.DataFrame}","page":"Simulation Utilities","title":"NEMStorageUnderUncertainty.results_to_jld2","text":"results_to_jld2(\n    results_file::String,\n    group::String,\n    key::String,\n    data::DataFrames.DataFrame\n)\n\n\nSummary\n\nSaves simulation results to a JLD2 (HDF5) data file\n\nSimulation results (data) are saved in results_file/group/key\n\nArguments\n\nresults_file: Path to file, including .jld2 extension\ngroup: Data group - actual or forecast\nkey: Dataset key - storage power capacity\ndata: Simulation results DataFrame\n\nMethods\n\nresults_to_jld2(results_file, group, key, data)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/simulation_utils.jl:114.\n\n\n\n\n\n","category":"method"},{"location":"simulation_utils/#NEMStorageUnderUncertainty.run_perfect_foresight-Tuple{MathOptInterface.OptimizerWithAttributes, NEMStorageUnderUncertainty.StorageDevice, NEMStorageUnderUncertainty.ActualData, NEMStorageUnderUncertainty.StorageModelFormulation, NEMStorageUnderUncertainty.DegradationModel}","page":"Simulation Utilities","title":"NEMStorageUnderUncertainty.run_perfect_foresight","text":"run_perfect_foresight(\n    optimizer::MathOptInterface.OptimizerWithAttributes,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    actual_data::NEMStorageUnderUncertainty.ActualData,\n    formulation::NEMStorageUnderUncertainty.StorageModelFormulation,\n    degradation::NEMStorageUnderUncertainty.DegradationModel;\n    silent,\n    time_limit_sec,\n    string_names\n) -> Any\n\n\nSummary\n\nRuns a perfect foresight model across the period of an ActualData instance.\n\nPerfect foresight entails:\n\nPerfect knowledge of future price (hence use of actual price data)\nComplete horizon lookahead\n\nArguments\n\noptimizer: A solver optimizer\nstorage: StorageDevice\nactual_data: ActualData\nformulation: A model formulation (StorageModelFormulation)\ndegradation: A degradation model (DegradationModel)\nsilent: default false. true to suppress solver output\ntime_limit_sec: default nothing. Float64 to impose solver time limit in seconds\nstring_names: default true. false to disable JuMP string names\n\nReturns\n\nSimulation results for the one binding decision point (i.e. at start of simulation period)\n\nMethods\n\nrun_perfect_foresight(\n    optimizer,\n    storage,\n    actual_data,\n    formulation,\n    degradation;\n    silent,\n    time_limit_sec,\n    string_names\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/simulation_utils.jl:68.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/constraints.jl\"]","category":"page"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_binding_throughput_limit!-Tuple{JuMP.Model, Dates.DateTime, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_binding_throughput_limit!","text":"_add_constraint_binding_throughput_limit!(\n    model::JuMP.Model,\n    binding_end::Dates.DateTime,\n    d_binding_max::Float64\n) -> JuMP.ConstraintRef{JuMP.Model}\n\n\nSummary\n\nAdds a throughput limit constraint that applies to the final binding time period in a simulation.\n\nAdds the following constraint to model:\n\nd_t_binding end  d_binding_max\n\nwhere d_binding_max is supplied\n\nArguments\n\nmodel: JuMP model\nbinding_end: End of the binding period, DateTime\nd_binding_max: Throughput limit in MWh, applicable at the end of the binding period\n\nMethods\n\n_add_constraint_binding_throughput_limit!(\n    model,\n    binding_end,\n    d_binding_max\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:214.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_initial_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_initial_soc!","text":"_add_constraint_initial_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> JuMP.ConstraintRef{JuMP.Model}\n\n\nSummary\n\nInitial state of charge constraint that uses soc₀ from storage.\n\nAdds the following constraint to model:\n\ne_1 - e_0 - left( q_1eta_chargetauright)+fracp_1taueta_discharge = 0\n\nwhere e_0 and eta are obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\ntau: Interval length in hours\n\nMethods\n\n_add_constraint_initial_soc!(model, storage, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:51.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_initial_throughput!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_initial_throughput!","text":"_add_constraint_initial_throughput!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> JuMP.ConstraintRef{JuMP.Model}\n\n\nSummary\n\nInitial throughput constraint that uses throughput₀ from storage.\n\nAdds the following constraint to model:\n\nd_1 - d_0 - p_1tau = 0\n\nwhere d_0 is obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\ntau: Interval length in hours\n\nMethods\n\n_add_constraint_initial_throughput!(\n    model,\n    storage,\n    times,\n    τ\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:127.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_intertemporal_soc!","text":"_add_constraint_intertemporal_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> JuMP.Containers.DenseAxisArray\n\n\nSummary\n\nIntertemporal state of charge constraints that describe state of charge evolution.\n\nAdds the following constraint to model if times has length ≥ 2:\n\ne_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n\neta are obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\ntau: Interval length in hours\n\nMethods\n\n_add_constraint_intertemporal_soc!(model, storage, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:86.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_intertemporal_throughput!-Tuple{JuMP.Model, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_intertemporal_throughput!","text":"_add_constraint_intertemporal_throughput!(\n    model::JuMP.Model,\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> JuMP.Containers.DenseAxisArray\n\n\nSummary\n\nIntertemporal throughput constraints that track throughput. See _add_variable_throughput!.\n\nAdds the following constraint to model if times has length ≥ 2:\n\nd_t-d_t-1 - p_ttau = 0\n\nArguments\n\nmodel: JuMP model\ntimes: A Vector of DateTimes\ntau: Interval length in hours\n\nMethods\n\n_add_constraint_intertemporal_throughput!(model, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:156.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraint_throughput_limit!-Tuple{JuMP.Model, Vector{Dates.DateTime}, Float64}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraint_throughput_limit!","text":"_add_constraint_throughput_limit!(\n    model::JuMP.Model,\n    times::Vector{Dates.DateTime},\n    d_max::Float64\n) -> JuMP.ConstraintRef{JuMP.Model}\n\n\nSummary\n\nAdds a throughput limit constraint that applies to the final time period in a simulation.\n\nAdds the following constraint to model:\n\nd_end  d_max\n\nwhere d_max is supplied\n\nArguments\n\nmodel: JuMP model\ntimes: A Vector of DateTimes\nd_max: Throughput limit in MWh, applicable at the end of times\n\nMethods\n\n_add_constraint_throughput_limit!(model, times, d_max)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:191.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#NEMStorageUnderUncertainty._add_constraints_charge_state!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Constraints","title":"NEMStorageUnderUncertainty._add_constraints_charge_state!","text":"_add_constraints_charge_state!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> Tuple{JuMP.Containers.DenseAxisArray, JuMP.Containers.DenseAxisArray}\n\n\nSummary\n\nConstraints that explicitly prevent simultaneous charging and discharging during a time interval t. Adds two constraints to model:\n\np_t - barpleft(1-u_tright) leq 0\nq_t - barpu_t leq 0\n\nIn the absence of these constraints, simultaneous charging and discharging was observed for a BESS device simulated for the following model formulations:\n\nStandardArbitrage\nStandardArbitrageThroughputPenalty, up to a certain throughput penalty\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_constraints_charge_state!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/constraints.jl:18.\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/objectives.jl\"]","category":"page"},{"location":"objectives/#NEMStorageUnderUncertainty._add_objective_standard!-Tuple{JuMP.Model, Vector{<:AbstractFloat}, Vector{Dates.DateTime}, Float64}","page":"Objectives","title":"NEMStorageUnderUncertainty._add_objective_standard!","text":"_add_objective_standard!(\n    model::JuMP.Model,\n    prices::Vector{<:AbstractFloat},\n    times::Vector{Dates.DateTime},\n    τ::Float64\n) -> Any\n\n\nSummary\n\nAdds a standard revenue-maximising objective function:\n\nbeginaligned\nmax_t quad  sum_ttaulambda_t(p_t - q_t)\nendaligned\n\nArguments\n\nmodel: JuMP model\nprices: A Vector of prices in /MWh\ntimes: A Vector of DateTimes\nτ: Frequency of prices in hours\n\nMethods\n\n_add_objective_standard!(model, prices, times, τ)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/objectives.jl:17.\n\n\n\n\n\n","category":"method"},{"location":"objectives/#NEMStorageUnderUncertainty._add_objective_throughput_penalty!-Tuple{JuMP.Model, Vector{<:AbstractFloat}, Vector{Dates.DateTime}, Float64, Float64, Float64, Float64, Float64}","page":"Objectives","title":"NEMStorageUnderUncertainty._add_objective_throughput_penalty!","text":"_add_objective_throughput_penalty!(\n    model::JuMP.Model,\n    prices::Vector{<:AbstractFloat},\n    times::Vector{Dates.DateTime},\n    τ::Float64,\n    d_0::Float64,\n    d_lifetime::Float64,\n    e_rated::Float64,\n    c_capital::Float64\n) -> Any\n\n\nSummary\n\nAdds a revenue-maximising objective function that penalises storage throughput/cycling.\n\nThe penalty is the proportion of the warrantied throughput lifetime of the storage device expended during the modelled period, multiplied by the cost of a new storage device. In other words, the storage device replacement cost is amortised across throughput.\n\nThis bears similarities to the energy throughput model in this paper.\n\nbeginaligned\nmax_t quad  sum_t^Ttaulambda_t(p_t - q_t) - fracd_T - d_0d_textrmlifetimee_textrmratedc_textrmcapital\nendaligned\n\nArguments\n\nmodel: JuMP model\nprices: A Vector of prices in /MWh\ntimes: A Vector of DateTimes\nτ: Frequency of prices in hours\nd_0: Initial throughput of storage device in MWh\nd_lifetime: Warrantied throughput lifetime of the storage device in MWh\ne_rated: Storage energy capacity in MWh\nc_capital: Capital cost of storage device in AUD/MWh\n\nMethods\n\n_add_objective_throughput_penalty!(\n    model,\n    prices,\n    times,\n    τ,\n    d_0,\n    d_lifetime,\n    e_rated,\n    c_capital\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/objectives.jl:59.\n\n\n\n\n\n","category":"method"},{"location":"simulations/#Simulation-Functions","page":"Simulation Functions","title":"Simulation Functions","text":"","category":"section"},{"location":"simulations/","page":"Simulation Functions","title":"Simulation Functions","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"simulations.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"simulations/#NEMStorageUnderUncertainty.simulate_storage_operation-Union{Tuple{T}, Tuple{MathOptInterface.OptimizerWithAttributes, NEMStorageUnderUncertainty.StorageDevice, NEMStorageUnderUncertainty.ActualData, NEMStorageUnderUncertainty.StorageModelFormulation, NEMStorageUnderUncertainty.DegradationModel}} where T<:Dates.Period","page":"Simulation Functions","title":"NEMStorageUnderUncertainty.simulate_storage_operation","text":"simulate_storage_operation(\n    optimizer::MathOptInterface.OptimizerWithAttributes,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    data::NEMStorageUnderUncertainty.ActualData,\n    model_formulation::NEMStorageUnderUncertainty.StorageModelFormulation,\n    degradation::NEMStorageUnderUncertainty.DegradationModel;\n    decision_start_time,\n    decision_end_time,\n    binding,\n    horizon,\n    capture_all_decisions,\n    silent,\n    show_progress,\n    time_limit_sec,\n    string_names,\n    relative_gap_in_results\n)\n\n\nSummary\n\nSimulate storage operation using actual data\n\nArguments\n\noptimizer: A solver optimizer\nstorage: StorageDevice\ndata: ActualData\nmodel_formulation: A model formulation (StorageModelFormulation)\ndegradation: A degradation model (DegradationModel)\ndecision_start_time: Decision start time\ndecision_end_time: Decision end time\nbinding: Binding horizon, out from decision_start_time\nhorizon: Model lookahead horizon, out from decision_start_time\ncapture_all_decisions: Default false. If true, report non binding decisions in results\nsilent: default false. true to suppress solver output\ntime_limit_sec: default nothing. Float64 to impose solver time limit in seconds\nstring_names: default true. false to disable JuMP string names\nrelative_gap_in_results: default false. If true, adds a column with relative MIP gap in results.\n\nReturns\n\nSimulation results\n\nMethods\n\nsimulate_storage_operation(\n    optimizer,\n    storage,\n    data,\n    model_formulation,\n    degradation;\n    decision_start_time,\n    decision_end_time,\n    binding,\n    horizon,\n    capture_all_decisions,\n    silent,\n    show_progress,\n    time_limit_sec,\n    string_names,\n    relative_gap_in_results\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/simulations.jl:309.\n\n\n\n\n\n","category":"method"},{"location":"simulations/#NEMStorageUnderUncertainty.simulate_storage_operation-Union{Tuple{T}, Tuple{MathOptInterface.OptimizerWithAttributes, NEMStorageUnderUncertainty.StorageDevice, NEMStorageUnderUncertainty.ForecastData, NEMStorageUnderUncertainty.StorageModelFormulation, NEMStorageUnderUncertainty.DegradationModel}} where T<:Dates.Period","page":"Simulation Functions","title":"NEMStorageUnderUncertainty.simulate_storage_operation","text":"simulate_storage_operation(\n    optimizer::MathOptInterface.OptimizerWithAttributes,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    data::NEMStorageUnderUncertainty.ForecastData,\n    model_formulation::NEMStorageUnderUncertainty.StorageModelFormulation,\n    degradation::NEMStorageUnderUncertainty.DegradationModel;\n    decision_start_time,\n    decision_end_time,\n    binding,\n    horizon,\n    capture_all_decisions,\n    silent,\n    show_progress,\n    time_limit_sec,\n    string_names,\n    relative_gap_in_results\n)\n\n\nSummary\n\nSimulate storage operation using forecast data\n\nArguments\n\noptimizer: A solver optimizer\nstorage: StorageDevice\ndata: ForecastData\nmodel_formulation: A model formulation (StorageModelFormulation)\ndegradation: A degradation model (DegradationModel)\ndecision_start_time: Decision start time\ndecision_end_time: Decision end time\nbinding: Binding horizon, out from decision_start_time\nhorizon: Model lookahead horizon, out from decision_start_time\ncapture_all_decisions: Default false. If true, report non binding decisions in results\nsilent: default false. true to suppress solver output\ntime_limit_sec: default nothing. Float64 to impose solver time limit in seconds\nstring_names: default true. false to disable JuMP string names\nrelative_gap_in_results: default false. If true, adds a column with relative MIP gap in results.\n\nReturns\n\nSimulation results\n\nMethods\n\nsimulate_storage_operation(\n    optimizer,\n    storage,\n    data,\n    model_formulation,\n    degradation;\n    decision_start_time,\n    decision_end_time,\n    binding,\n    horizon,\n    capture_all_decisions,\n    silent,\n    show_progress,\n    time_limit_sec,\n    string_names,\n    relative_gap_in_results\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/simulations.jl:420.\n\n\n\n\n\n","category":"method"},{"location":"formulations/#Model-Formulations","page":"Model Formulations","title":"Model Formulations","text":"","category":"section"},{"location":"formulations/","page":"Model Formulations","title":"Model Formulations","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/formulations.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"formulations/#NEMStorageUnderUncertainty.ArbitrageThroughputPenalty","page":"Model Formulations","title":"NEMStorageUnderUncertainty.ArbitrageThroughputPenalty","text":"struct ArbitrageThroughputPenalty <: NEMStorageUnderUncertainty.StorageModelFormulation\n\nd_lifetime::Float64\nc_capital::Float64\n\nSummary\n\nMaximises storage revenue subject to pro-rata penalisation of throughput/cycling:\n\nAll periods are treated (weighted) equally\nNo cycling/throughput limits are imposed on the storage device\nRevenue is defined by the spot price for energy and is penalised based on throughput\nThe penalty is the proportion of the warrantied throughput lifetime of the storage device expended during the modelled period, multiplied by the cost of a new storage device\nIntertemporal SoC constraints are applied, including from e₀ (initial SoC of storage device) to e₁ (first modelled SoC)\n\nbeginaligned\n  max_t quad  sum_t=1^Ttaulambda_t(p_t - q_t) - fracd_T - d_0d_lifetime e_rated c_capital \n  textrmst quad  u_t in 01    \n   p_t geq 0 \n   q_t geq 0 \n   p_t - barpleft(1-u_tright) leq 0\n   q_t - barpu_t leq 0\n   underlinee leq e_t leq bare    \n   e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n   e_1 - e_0 - left( q_1eta_chargetauright)+fracp_1taueta_discharge = 0\n   d_t-d_t-1 - p_ttau = 0\n   d_1 - d_0 - p_1tau = 0\nendaligned\n\nAttributes\n\nd_lifetime: Warrantied throughput lifetime of the storage device in MWh\nc_capital: Capital cost of storage device in AUD/MWh\n\n```\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty.DegradationModel","page":"Model Formulations","title":"NEMStorageUnderUncertainty.DegradationModel","text":"abstract type DegradationModel <: NEMStorageUnderUncertainty.Formulation\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty.NoDegradation","page":"Model Formulations","title":"NEMStorageUnderUncertainty.NoDegradation","text":"struct NoDegradation <: NEMStorageUnderUncertainty.DegradationModel\n\nNo storage degradation modelled in simulations.\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty.StandardArbitrage","page":"Model Formulations","title":"NEMStorageUnderUncertainty.StandardArbitrage","text":"struct StandardArbitrage <: NEMStorageUnderUncertainty.StorageModelFormulation\n\nSummary\n\nMaximises storage revenue:\n\nAll periods are treated (weighted) equally\nNo cycling/throughput limits are modelled\nRevenue is purely defined by the spot price for energy\nIntertemporal SoC constraints are applied, including from e₀ (initial SoC of storage device) to e₁ (first modelled SoC)\n\nbeginaligned\n  max_t quad  sum_t=1^Ttaulambda_t(p_t-q_t)\n  textrmst quad  u_t in 01    \n   p_t geq 0 \n   q_t geq 0 \n   p_t - barpleft(1-u_tright) leq 0\n   q_t - barpu_t leq 0\n   underlinee leq e_t leq bare    \n   e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n   e_1 - e_0 - left( q_1eta_chargetauright)+fracp_1taueta_discharge = 0\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty.StandardArbitrageThroughputLimit","page":"Model Formulations","title":"NEMStorageUnderUncertainty.StandardArbitrageThroughputLimit","text":"struct StandardArbitrageThroughputLimit <: NEMStorageUnderUncertainty.StorageModelFormulation\n\nthroughput_mwh_per_year::Float64\n\nSummary\n\nMaximises storage revenue subject to pro-rata application of throughput limits:\n\nAll periods are treated (weighted) equally\nA throughput limit is modelled, with an annual throughput limit (d_max) specified\nEach simulation includes this limit applied on a pro rata basis (i.e. proportion of year in each model horizon)\nd_max for a model period is given by (where d₀ is the initial storage device throughput): d_max = d_0 + fract_T - t_1 + 560 times 24 times 365 times d_limit\nd_binding_max applies a similar limit to the binding period\nd_limit is the throughput limit in MWh/year\nRevenue is purely defined by the spot price for energy\nIntertemporal SoC constraints are applied, including from e₀ (initial SoC of storage device) to e₁ (first modelled SoC)\n\nbeginaligned\n  max_t quad  sum_t=1^Ttaulambda_t(p_t-q_t)\n  textrmst quad  u_t in 01    \n   p_t geq 0 \n   q_t geq 0 \n   p_t - barpleft(1-u_tright) leq 0\n   q_t - barpu_t leq 0\n   underlinee leq e_t leq bare    \n   e_t-e_t-1- left( q_teta_chargetauright)+fracp_ttaueta_discharge = 0\n   e_1 - e_0 - left( q_1eta_chargetauright)+fracp_1taueta_discharge = 0\n   d_t-d_t-1 - p_ttau = 0\n   d_1 - d_0 - p_1tau = 0\n   d_t_binding end  d_binding_max \n   d_T  d_max\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"formulations/#NEMStorageUnderUncertainty.StorageModelFormulation","page":"Model Formulations","title":"NEMStorageUnderUncertainty.StorageModelFormulation","text":"abstract type StorageModelFormulation <: NEMStorageUnderUncertainty.Formulation\n\n\n\n\n\n","category":"type"},{"location":"build/#Model-Building-and-Execution","page":"Model Building and Execution","title":"Model Building and Execution","text":"","category":"section"},{"location":"build/","page":"Model Building and Execution","title":"Model Building and Execution","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/build_and_run.jl\"]\nFilter = n -> !startswith(string(nameof(n)), \"_\")","category":"page"},{"location":"build/#NEMStorageUnderUncertainty.run_model-Tuple{MathOptInterface.OptimizerWithAttributes, NEMStorageUnderUncertainty.StorageDevice, Vector{<:AbstractFloat}, Vector{Dates.DateTime}, Dates.DateTime, Float64, NEMStorageUnderUncertainty.StorageModelFormulation, NEMStorageUnderUncertainty.DegradationModel}","page":"Model Building and Execution","title":"NEMStorageUnderUncertainty.run_model","text":"run_model(\n    optimizer::MathOptInterface.OptimizerWithAttributes,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    prices::Vector{<:AbstractFloat},\n    times::Vector{Dates.DateTime},\n    binding_end_time::Dates.DateTime,\n    τ::Float64,\n    formulation::NEMStorageUnderUncertainty.StorageModelFormulation,\n    degradation::NEMStorageUnderUncertainty.DegradationModel;\n    silent,\n    time_limit_sec,\n    string_names\n) -> JuMP.Model\n\n\nSummary\n\nRuns a model using data in prices, times and τ (interval duration in hours). The type of model constructed and run is dependent on the formulation\n\nArguments\n\noptimizer: A solver optimizer\nstorage: StorageDevice\nprices: Energy prices in /MW/hr that corresponds to prices at times\ntimes: Times to run model for\nbinding_end_time: Binding period end time\nτ: Interval duration in hours\nformulation: A model formulation (StorageModelFormulation)\n\nReturns\n\nA JuMP model if the solution is optimal (within solver tolerances)\nA JuMP model with warning if a time/iteration limit is hit\nThrows and error if infeasible/unbounded/etc.\n\nMethods\n\nrun_model(\n    optimizer,\n    storage,\n    prices,\n    times,\n    binding_end_time,\n    τ,\n    formulation,\n    degradation;\n    silent,\n    time_limit_sec,\n    string_names\n)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/build_and_run.jl:209.\n\n\n\n\n\n","category":"method"},{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"Modules = [NEMStorageUnderUncertainty]\nPages = [\"model/variables.jl\"]","category":"page"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_charge_state!-Tuple{JuMP.Model, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_charge_state!","text":"_add_variable_charge_state!(\n    model::JuMP.Model,\n    times::Vector{Dates.DateTime}\n) -> JuMP.Containers.DenseAxisArray{JuMP.VariableRef, 1, Tuple{Vector{Dates.DateTime}}, Tuple{JuMP.Containers._AxisLookup{Dict{Dates.DateTime, Int64}}}}\n\n\nSummary\n\nAdds binary variable that indicates when the device is charging (i.e. u_t=1).\n\nArguments\n\nmodel: JuMP model\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variable_charge_state!(model, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:55.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_soc!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_soc!","text":"_add_variable_soc!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> JuMP.Containers.DenseAxisArray\n\n\nSummary\n\nAdds variable that tracks state-of-charge (SoC, e_t).\n\nThe following variable bound is applied: underlinee leq e_t leq bare, where the limits represent the lower and upper SoC limits obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variable_soc!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:39.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variable_throughput!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variable_throughput!","text":"_add_variable_throughput!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> JuMP.Containers.DenseAxisArray\n\n\nSummary\n\nAdds variable that tracks throughput in MWh (d_t).\n\nThroughput is defined as the cumulative energy delivered (i.e. discharged) by the device.\n\nThe following variable bound is applied: d_0 leq d_t, where the limit represents the initial throughput obtained from storage.\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variable_throughput!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:73.\n\n\n\n\n\n","category":"method"},{"location":"variables/#NEMStorageUnderUncertainty._add_variables_power!-Tuple{JuMP.Model, NEMStorageUnderUncertainty.StorageDevice, Vector{Dates.DateTime}}","page":"Variables","title":"NEMStorageUnderUncertainty._add_variables_power!","text":"_add_variables_power!(\n    model::JuMP.Model,\n    storage::NEMStorageUnderUncertainty.StorageDevice,\n    times::Vector{Dates.DateTime}\n) -> Tuple{JuMP.Containers.DenseAxisArray, JuMP.Containers.DenseAxisArray}\n\n\nSummary\n\nAdds variables for charging in MW (q_t) and discharging in MW (p_t).\n\nThe following variable bounds are applied:\n\n0 leq p_t leq barp\n0 leq q_t leq barp\n\nArguments\n\nmodel: JuMP model\nstorage: A StorageDevice\ntimes: A Vector of DateTimes\n\nMethods\n\n_add_variables_power!(model, storage, times)\n\ndefined at /home/runner/work/NEMStorageUnderUncertainty/NEMStorageUnderUncertainty/src/model/variables.jl:14.\n\n\n\n\n\n","category":"method"},{"location":"#NEMStorageUnderUncertainty-Documentation","page":"Home","title":"NEMStorageUnderUncertainty Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modelling framework built to explore the impact of future market information (forecasts) on the operation of energy storage in the National Electricity Market (NEM).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Terminology used in this repo is outlined in Terminology","category":"page"},{"location":"","page":"Home","title":"Home","text":"These pages document the source code used to run storage simulations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Storage Devices contains the storage devices modelled\nPrice Data Compilers documents the functions that compile, clean and assemble actual and forecast price data for use in models/simulations\nModel Formulations documents the mathematical optimisation problems formulated for each model horizon\nSimulation Functions documents the code that is used to string model horizons together and simulate the rolling horizon/optimal control problem\nSimulation Results Processing and Calculations documents simulation results compilers, and functions that calculate aggregate results (e.g. annual revenue, value of perfect information, value of perfect foresight)","category":"page"}]
}
